#+AUTHOR: Karolos Triantafyllou
#+TITLE: GNU Emacs Configuration

* Table of Contents                          :TOC:
- [[#about][About]]
- [[#emacs-initialization][Emacs Initialization]]
  - [[#package-sources][Package sources]]
  - [[#use-package][use-package]]
- [[#start-up][Start up]]
  - [[#better-defaults][Better Defaults]]
  - [[#turn-off-mouse-interface][Turn Off Mouse Interface]]
  - [[#fonts][Fonts]]
  - [[#theme][Theme]]
- [[#languages][Languages]]
  - [[#lsp][LSP]]
  - [[#c][C++]]
  - [[#emacs-lisp][Emacs Lisp]]
  - [[#json][JSON]]
  - [[#lua][Lua]]
  - [[#shell-script][Shell-script]]
  - [[#yaml][YAML]]
- [[#advanced-configuration][Advanced Configuration]]
  - [[#alert][Alert]]
  - [[#auto-completion][Auto-Completion]]
  - [[#buffers][Buffers]]
  - [[#dired][Dired]]
  - [[#ending-up][Ending Up]]
  - [[#hydra][Hydra]]
  - [[#general][General]]
  - [[#icons][Icons]]
  - [[#ivy][Ivy]]
  - [[#linters][Linters]]
  - [[#navigation][Navigation]]
  - [[#parentheses][Parentheses]]
  - [[#pdf][PDF]]
  - [[#point-and-region][Point and Region]]
  - [[#projectile][Projectile]]
  - [[#recent-files][Recent Files]]
  - [[#version-control][Version Control]]
  - [[#whitespaces][Whitespaces]]
  - [[#windows][Windows]]
  - [[#word-wrap][Word Wrap]]
  - [[#yasnippet][YASnippet]]
- [[#org-mode][Org-Mode]]
  - [[#agenda][Agenda]]
  - [[#bullets][Bullets]]
  - [[#capture][Capture]]
  - [[#contacts][Contacts]]
  - [[#customization][Customization]]
  - [[#journal][Journal]]
  - [[#languages-1][Languages]]

* About

This configuration file exists to simplify Emacs by adding scripts, functions, etc.

In order to manage package configurations, we need the [[https://github.com/wjiegley/use-package/][use-package]]
package fron John Wiegly.

This configuration is based on the following users:
- [[https://github.com/jwiegley/dot-emacs/][John Wiegley]] (=jwiegley=);
- [[https://github.com/rememberYou/.emacs.d][Terencio Agozzino]] (=rememberYou=)

* Emacs Initialization

** Package sources

In order to install packages, we need to configure the package sources.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                           ("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")))
#+END_SRC

** use-package

For us to be able to manage our configurations with =use-package=, we must first install it,
if it hasn't been already.

#+BEGIN_SRC emacs-lisp :tangle yes
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (use-package delight :ensure t)
  (use-package use-package-ensure-system-package :ensure t)
#+END_SRC

* Start up
** Better Defaults

For a better user experience of GNU Emacs, here are some default values.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default
    ad-redefinition-action 'accept
    cursor-in-non-selected-windows t
    display-time-default-load-average nil
    fill-column 80
    help-window-select t
    indent-tabs-mode nil
    inhibit-startup-screen t
    initial-scratch-message ""
    kill-ring-max 128
    mark-ring-max 128
    load-prefer-newer t
    scroll-conservatively most-positive-fixnum
    select-enable-clipboard t
    tab-width 4
    use-package-always-ensure t
    user-full-name "Karolos Triantafyllou"
    user-mail-address "karolos.triantafyllou@gmail.com"
    vc-follow-symlinks t
    view-read-only t
    c-default-style "bsd"
    c-basic-offset 4)
  (cd "~/")
  (column-number-mode 1)
  (global-display-line-numbers-mode)
  (display-time-mode 1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (global-hl-line-mode)
  (set-default-coding-systems 'utf-8)
  (show-paren-mode 1)
#+END_SRC

** Turn Off Mouse Interface

Since we will never be using the mouse with GNU Emacs, we do not need certain graphical elements,
such as the menu bar, toolbar, etc.

#+BEGIN_SRC emacs-lisp :tangle yes
  (when window-system
    (menu-bar-mode -1)   ; Disable the menu bar
    (scroll-bar-mode -1) ; Disable the scroll bar
    (tool-bar-mode -1)   ; Disable the tool bar
    (tooltip-mode -1))   ; Disable the tooltips
#+END_SRC
** Fonts

Since I spend most of my time in GNU Emacs, it is important to use a font that will help with
our reading.

Source Code Pro is one of the best monospaced fonts. You have to install it with your system manager.

#+BEGIN_SRC emacs-lisp :tangle yes
  (set-face-attribute 'default nil :font "Source Code Pro Medium")
  (set-fontset-font t 'latin "Noto Sans")
#+END_SRC

** Theme

For this installation, we will be using [[https://github.com/articicestudio/nord-emacs][nord-theme]], combined with [[https://github.com/seagle0128/doom-modeline][doom-modeline]].

*NOTE:* We are goint to be using [[#Icons][all-the-icons]] in order to show the icons in =doom-modeline=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package doom-themes
    :config (load-theme 'doom-nord t))

  (use-package doom-modeline
    :config (doom-modeline-mode))

  (use-package fancy-battery
    :after doom-modeline
    :hook (after-init . fancy-battery-mode))

  (use-package solaire-mode
    :custom (solair-mode-remap-fringe t)
    :config
    (solaire-mode-swap-bg)
    (solaire-global-mode +1))
#+END_SRC

* Languages

** LSP

Although not a language itself, with /LSP/ (/Language Server Protocol/) we can use different
servers according to the programming language that we want to use.

The client can be found at [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]].

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package lsp-mode
    :hook ((c-mode c++-mode dart-mode java-mode python-mode xml-mode) . lsp)
    :custom
    (lsp-prefer-flymake nil))

  (use-package lsp-ui)
  (use-package company-lsp)

  (use-package dap-mode
    :after lsp-mode
    :config
    (dap-mode t)
    (dap-ui-mode t))
#+END_SRC

** C++

In order to have a fast and stable environment, using [[#LSP][LSP]] as a client and [[https://github.com/MaskRay/ccls][ccls]] as a server
works optimally.

=ccls= must be installed with your package manager, so it can be used by GNU Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ccls
    :after projectile
    :ensure-system-package ccls
    :custom
    (ccls-args nil)
    (ccls-executable (executable-find "ccls"))
    (projectile-project-root-files-top-down-recurring
     (append '("compile_commands.json" ".ccls")
             projectile-project-root-files-top-down-recurring))
    :config (add-to-list 'projectile-globally-ignored-directories ".ccls-cache"))
#+END_SRC

*** Clang-format

Having a consistent and beautiful code-base is paramount to coding
efficiently. Thus, we need [[https://github.com/SavchenkoValeriy/emacs-clang-format-plus][clang-format+]].

#+BEGIN

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package clang-format+
    :hook ('c++-mode . clang-format+-mode))
#+END_SRC

** Emacs Lisp

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package elisp-mode :ensure nil :delight "ξ ")
#+END_SRC

*** Eldoc

Provides minibuffer hints when working with Emacs Lisp.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package eldoc
    :delight
    :hook (emacs-lisp-mode . eldoc-mode))
#+END_SRC

** JSON

JSON is used a lot, especially in the web.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package json-mode
    :delight "J "
    :mode "\\.json\\'"
    :hook (before-save . my/json-mode-before-save-hook)
    :preface
    (defun my/json-mode-before-save-hook ()
      (when (eq major-mode 'json-mode)
        (json-pretty-print-buffer)))

    (defun my/json-array-of-numbers-on-one-line (encode array)
      "Prints the arrays of nymbers in one line."
      (let* ((json-encoding-pretty-print
              (and json-encoding-pretty-print
                   (not (loop for x across array always (numberp x)))))
             (json-encoding-separator (if json-encoding-pretty-print "," ", ")))
        (funcall encode array)))
    :config (advice-add 'json-encode-array :around #'my/json-array-of-numbers-on-one-line))
#+END_SRC

** Lua

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package lua-mode
    :delight "Λ "
    :mode "\\.lua\\'"
    :interpreter ("lua" . lua-mode))
#+END_SRC

** Shell-script

When we create/edit a shell script, we automatically grant it execution rights (=chmod +x=).

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package sh-script
    :ensure nil
    :hook (after-save . executable-make-buffer-file-executable-if-script-p))
#+END_SRC

** YAML

=yaml-mode= gives us the possibility to easily manage =.yml= files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package yaml-mode
    :delight "ψ "
    :mode "\\.yml\\'"
    :interpreter ("yml" . yml-mode))
#+END_SRC

* Advanced Configuration

** Alert

Most packages use =alerts= to make notifications with =libnotify=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package alert
    :custom (alert-default-style 'libnotify))
#+END_SRC

** Auto-Completion

=company= provides auto-completion at point and displays a small pop-in containing the candidates.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company
    :delight
    :custom
    (company-begin-commands '(self-insert-command))
    (company-idle-delay .1)
    (company-minimim-prefix-length 2)
    (company-show-numbers t)
    (company-tooltip-align-annotations 't)
    (global-company-mode t))
#+END_SRC

We also use =company= with =company-box= that allows a front-end with icons.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-box
    :after company
    :delight
    :hook (company-mode . company-box-mode))
#+END_SRC
** Buffers

Buffers can quickly become a mess. It is useful to be able to find our way easily.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ibuffer
    :bind ("C-x C-b" . ibuffer))

  (use-package ibuffer-projectile
    :after ibuffer
    :preface
    (defun my/ibuffer-projectile ()
      (ibuffer-projectile-set-filter-groups)
      (unless (eq ibuffer-sorting-mode 'alphabetic)
        (ibuffer-do-sort-by-alphabetic)))
    :hook (ibuffer . my/ibuffer-projectile))
#+END_SRC

Some buffers should not be deleted by accident:

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar *protected-buffers* '("*scratch*" "*Messages*")
    "Buffers that cannot be killed.")
(defun my/protected-buffers ()
"Protects some buffers from being killed."
    (dolist (buffer *protected-buffers*)
      (with-current-buffer buffer
        (emacs-lock-mode 'kill))))

  (add-hook 'after-init-hook #'my/protected-buffers)
#+END_SRC

** Dired

Here we fix some defaults for dired.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dired
    :ensure nil
    :delight "Dired "
    :custom
    (dired-auto-revert-buffer t)
    (dired-dwim-target t)
    (dired-hide-details-hide-symlink-targets nil)
    (dired-listing-switches "-alh")
    (dired-ls-F-marks-symlinks nil)
    (dired-recursive-copies 'always))

  (use-package dired-narrow
    :bind (("C-c C-n" . dired-narrow)
           ("C-c C-f" . dired-narrow-fuzzy)
           ("C-c C-r" . dired-narrow-regexp)))

  (use-package dired-subtree
    :bind (:map dired-mode-map
                ("<backtab>" . dired-subtree-cycle)
                ("<tab>" . dired-subtree-toggle)))
#+END_SRC

** Ending Up

I'm using an =.org= file to maintain my GNU Emacs configuration. However, at his
launch, it will load the =config.el= source file for a faster loading.

The code below, executes =org-babel-tangle= asynchronously when
=config.org= is saved.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package async)

  (defvar *config-file* (expand-file-name "config.org" user-emacs-directory)
    "The configuration file.")

  (defvar *config-last-change* (nth 5 (file-attributes *config-file* user-emacs-directory))
    "Last modification time of the configuration file.")

  (defvar *show-async-tangle-results* nil
    "Keeps *emacs* async buffers around for later inspection.")

  (defun my/config-updated ()
    "Checks if the configuration file has been updated since the last time."
    (time-less-p *config-last-change*
                 (nth 5 (file-attributes *config-file*))))

  (defun my/config-tangle ()
    "Tangles the org file asynchronously."
    (when (my/config-updated)
      (setq *config-last-change*
            (nth 5 (file-attributes *config-file*)))
      (my/async-babel-tangle *config-file*)))

  (defun my/async-babel-tangle (org-file)
    "Tangles the org file asynchronously."
    (let ((init-tangle-start-time (current-time))
          (file (buffer-file-name))
          (async-quiet-switch "-q"))
      (async-start
       `(lambda ()
          (require 'org)
          (org-babel-tangle-file ,org-file))
       (unless *show-async-tangle-results*
         `(lambda (result)
            (if result
                (message "SUCCESS: %s successfully tangled (%.2fs)."
                         ,org-file
                         (float-time (time-subtract (current-time)
                                                    ',init-tangle-start-time)))
              (message "ERROR: %s as tangle failed." ,org-file)))))))
#+END_SRC
** Hydra

Hydra allows me to display a list of all the commands implemented in the echo
area and easily interact with them.

#+BEGIN_QUOTE
Once you summon the Hydra through the prefixed binding (the body + any one
head), all heads can be called in succession with only a short extension.

The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head,
arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his
original purpose, calling his proper command. This makes the Hydra very
seamless, it's like a minor mode that disables itself auto-magically.

[[https://github.com/abo-abo/hydra][Oleh Krehel]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hydra
    :bind (("C-c I" . hydra-image/body)
           ("C-c L" . hydra-ledger/body)
           ("C-c M" . hydra-merge/body)
           ("C-c T" . hydra-tool/body)
           ("C-c b" . hydra-btoggle/body)
           ("C-c c" . hydra-clock/body)
           ("C-c e" . hydra-erc/body)
           ("C-c f" . hydra-flycheck/body)
           ("C-c g" . hydra-go-to-file/body)
           ("C-c m" . hydra-magit/body)
           ("C-c o" . hydra-org/body)
           ("C-c p" . hydra-projectile/body)
           ("C-c q" . hydra-query/body)
           ("C-c s" . hydra-spelling/body)
           ("C-c t" . hydra-tex/body)
           ("C-c u" . hydra-upload/body)
           ("C-c w" . hydra-windows/body)))

  (use-package major-mode-hydra
    :after hydra
    :preface
    (defun with-alltheicon (icon str &optional height v-adjust)
      "Displays an icon from all-the-icon."
      (s-concat (all-the-icons-alltheicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

    (defun with-faicon (icon str &optional height v-adjust)
      "Displays an icon from Font Awesome icon."
      (s-concat (all-the-icons-faicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

    (defun with-fileicon (icon str &optional height v-adjust)
      "Displays an icon from the Atom File Icons package."
      (s-concat (all-the-icons-fileicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

    (defun with-octicon (icon str &optional height v-adjust)
      "Displays an icon from the GitHub Octicons."
      (s-concat (all-the-icons-octicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str)))
#+END_SRC

*** Hydra / BToggle

Group a lot of commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-btoggle
    (:hint nil :color amaranth :quit-key "q" :title (with-faicon "toggle-on" "Toggle" 1 -0.05))
    ("Basic"
     (("a" abbrev-mode "abbrev" :toggle t)
      ("h" global-hungry-delete-mode "hungry delete" :toggle t))
     "Coding"
     (("e" electric-operator-mode "electric operator" :toggle t)
      ("F" flyspell-mode "flyspell" :toggle t)
      ("f" flycheck-mode "flycheck" :toggle t)
      ("l" lsp-mode "lsp" :toggle t)
      ("s" smartparens-mode "smartparens" :toggle t))
     "UI"
     (("i" ivy-rich-mode "ivy-rich" :toggle t))))
#+END_SRC

*** Hydra / Clock

Group clock commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-clock
    (:hint nil :color teal :quit-key "q" :title (with-faicon "clock-o" "Clock" 1 -0.05))
    ("Action"
     (("c" org-clock-cancel "cancel")
      ("d" org-clock-display "display")
      ("e" org-clock-modify-effort-estimate "effort")
      ("i" org-clock-in "in")
      ("j" org-clock-goto "jump")
      ("o" org-clock-out "out")
      ("r" org-clock-report "report"))))
#+END_SRC

*** Hydra / ERC

Group ERC commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-erc
    (:hint nil :color teal :quit-key "q" :title (with-faicon "comments-o" "ERC" 1 -0.05))
    ("Action"
     (("b" my/erc-browse-last-url "browse last url")
      ("c" my/erc-start-or-switch "connect")
      ("d" erc-quit-server "disconnect")
      ("j" erc-join-channel "join")
      ("n" erc-channel-names "names")
      ("o" my/erc-get-ops "ops")
      ("u" my/erc-count-users "users")
      ("r" my/erc-reset-track-mode "reset track mode"))))
#+END_SRC

*** Hydra / Flycheck

Group Flycheck commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-flycheck
    (:hint nil :color teal :quit-key "q" :title (with-faicon "plane" "Flycheck" 1 -0.05))
    ("Checker"
     (("?" flycheck-describe-checker "describe")
      ("d" flycheck-disable-checker "disable")
      ("m" flycheck-mode "mode")
      ("s" flycheck-select-checker "select"))
     "Errors"
     (("<" flycheck-previous-error "previous" :color pink)
      (">" flycheck-next-error "next" :color pink)
      ("f" flycheck-buffer "check")
      ("l" flycheck-list-errors "list"))
     "Other"
     (("M" flycheck-manual "manual")
      ("v" flycheck-verify-setup "verify setup"))))
#+END_SRC

*** Hydra / Image

Group images commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-image
    (:hint nil :color pink :quit-key "q" :title (with-faicon "file-image-o" "Images" 1 -0.05))
    ("Action"
     (("r" image-rotate "rotate")
      ("s" image-save "save" :color teal))
      "Zoom"
      (("-" image-decrease-size "out")
       ("+" image-increase-size "in")
       ("=" image-transform-reset "reset"))))
#+END_SRC

*** Hydra / Ledger

Group Ledger commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-ledger
    (:hint nil :color teal :quit-key "q" :title (with-faicon "usd" "Ledger" 1 -0.05))
    ("Action"
     (("b" leadger-add-transaction "add")
      ("c" ledger-mode-clean-buffer "clear")
      ("i" ledger-copy-transaction-at-point "copy")
      ("s" ledger-delete-current-transaction "delete")
      ("r" ledger-report "report"))))
#+END_SRC

*** Hydra / Magit

Group Magit commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-magit
    (:hint nil :color teal :quit-key "q" :title (with-alltheicon "git" "Magit" 1 -0.05))
    ("Action"
     (("b" magit-blame "blame")
      ("c" magit-clone "clone")
      ("i" magit-init "init")
      ("l" magit-log-buffer-file "commit log (current file)")
      ("L" magit-log-current "commit log (project)")
      ("s" magit-status "status"))))
#+END_SRC

*** Hydra / Merge

Group Merge commands.
#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-merge
    (:hint nil :color pink :quit-key "q" :title (with-alltheicon "git" "Merge" 1 -0.05))
    ("Move"
     (("n" smerge-next "next")
      ("p" smerge-prev "previous"))
     "Keep"
     (("RET" smerge-keep-current "current")
      ("a" smerge-keep-all "all")
      ("b" smerge-keep-base "base")
      ("l" smerge-keep-lower "lower")
      ("u" smerge-keep-upper "upper"))
     "Diff"
     (("<" smerge-diff-base-upper "upper/base")
      ("=" smerge-diff-upper-lower "upper/lower")
      (">" smerge-diff-base-lower "base/lower")
      ("R" smerge-refine "redefine")
      ("E" smerge-ediff "ediff"))
     "Other"
     (("C" smerge-combine-with-next "combine")
      ("r" smerge-resolve "resolve")
      ("k" smerge-kill-current "kill current"))))
#+END_SRC

*** Hydra / Org

Group Org commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-org
    (:hint nil :color teal :quit-key "q" :title (with-fileicon "org" "Org" 1 -0.05))
    ("Action"
     (("A" my/org-archive-done-tasks "archive")
      ("a" org-agenda "agenda")
      ("c" org-capture "capture")
      ("d" org-decrypt-entry "decrypt")
      ("i" org-insert-link-global "insert-link")
      ("j" my/org-jump "jump-task")
      ("k" org-cut-subtree "cut-subtree")
      ("o" org-open-at-point-global "open-link")
      ("r" org-refile "refile")
      ("s" org-store-link "store-link")
      ("t" org-show-todo-tree "todo-tree"))))
#+END_SRC

*** Hydra / Projectile

Group Projectile commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-projectile
    (:hint nil :color teal :quit-key "q" :title (with-faicon "rocket" "Projectile" 1 -0.05))
    ("Buffers"
     (("b" counsel-projectile-switch-to-buffer "list")
      ("k" projectile-kill-buffers "kill all")
      ("S" projectile-save-project-buffers "save all"))
     "Find"
     (("d" counsel-projectile-find-dir "directory")
      ("D" projectile-dired "root")
      ("f" counsel-projectile-find-file "file")
      ("p" counsel-projectile-switch-project "project"))
     "Other"
     (("i" projectile-invalidate-cache "reset cache"))
     "Search"
     (("r" projectile-replace "replace")
      ("R" projectile-replace-regexp "regexp replace")
      ("s" counsel-rg "search"))))
#+END_SRC

*** Hydra / Query

Group Query commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-query
    (:hint nil :color teal :quit-key "q" :title (with-faicon "search" "Engine-Mode" 1 -0.05))
    ("Query"
     (("a" engine/search-amazon "amazon")
      ("d" engine/search-duckduckgo "duckduckgo")
      ("g" engine/search-github "github")
      ("i" engine/search-google-images "google images")
      ("m" engine/search-google-maps "google maps")
      ("s" engine/search-stack-overflow "stack overflow")
      ("w" engine/search-wikipedia "wikipedia")
      ("y" engine/search-youtube "youtube"))))
#+END_SRC

*** Hydra / Spelling

Group spelling commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-spelling
    (:hint nil :color teal :quit-key "q" :title (with-faicon "magic" "Spelling" 1 -0.05))
    ("Checker"
     (("c" langtool-correct-buffer "correction")
      ("C" langtool-check-done "clear")
      ("d" ispell-change-dictionary "dictionary")
      ("l" (message "Current language: %s (%s)" langtool-default-language ispell-current-dictionary) "language")
      ("s" my/switch-language "switch")
      ("w" wiki-summary "wiki"))
     "Errors"
     (("<" flyspell-correct-previous "previous" :color pink)
      (">" flyspell-correct-next "next" :color pink)
      ("f" langtool-check "find"))))
#+END_SRC

*** Hydra / TeX

Group TeX commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-tex
    (:hint nil :color teal :quit-key "q" :title (with-fileicon "tex" "LaTeX" 1 -0.05))
    ("Action"
     (("g" reftex-goto-label "goto")
      ("r" reftex-query-replace-document "replace")
      ("s" counsel-rg "search")
      ("t" reftex-toc "table of content"))))
#+END_SRC

*** Hydra / Tool

Group Tool commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-tool
    (:hint nil :color teal :quit-key "q" :title (with-faicon "briefcase" "Tool" 1 -0.05))
    ("Network"
     (("c" ipcalc "subnet calculator")
      ("i" ipinfo "ip info"))))
#+END_SRC

*** Hydra / TypeScript

Group TypeScript commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-typescript (:color blue)
    "
    ^
    ^TypeScript^          ^Do^
    ^──────────^──────────^──^───────────
    _q_ quit             _b_ back
    ^^                   _e_ errors
    ^^                   _j_ jump
    ^^                   _r_ references
    ^^                   _R_ restart
    ^^                   ^^
    "
    ("q" nil)
    ("b" tide-jump-back)
    ("e" tide-project-errors)
    ("j" tide-jump-to-definition)
    ("r" tide-references)
    ("R" tide-restart-server))
#+END_SRC

*** Hydra / Upload

Group upload commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-upload
    (:hint nil :color teal :quit-key "q" :title (with-faicon "cloud-upload" "Upload" 1 -0.05))
    ("Action"
     (("b" webpaste-paste-buffe "buffer")
      ("i" imgbb-upload "image")
      ("r" webpaste-paste-region "region"))))
#+END_SRC

*** Hydra / Windows

Group window-related commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define hydra-windows
    (:hint nil :forein-keys warn :quit-key "q" :title (with-faicon "windows" "Windows" 1 -0.05))
    ("Window"
     (("b" balance-windows "balance")
      ("i" enlarge-window "heighten")
      ("j" shrink-window-horizontally "narrow")
      ("k" shrink-window "lower")
      ("l" enlarge-window-horizontally "widen")
      ("s" switch-window-then-swap-buffer "swap" :color teal))
     "Zoom"
     (("-" text-scale-decrease "out")
      ("+" text-scale-increase "in")
      ("=" (text-scale-increase 0) "reset"))))
#+BEGIN_SRC

** General

*** =aggressive-indent-

Auto-indent code as you write.

#+BEGIN_QUOTE
=electric-indent-mode= is enough to keep your code nicely aligned when all you
do is type. However, once you start shifting blocks around, transposing lines,
or slurping and barfing sexps, indentation is bound to go wrong.

=aggressive-indent-mode= is a minor mode that keeps your code *always* indented.
It reindents after every change, making it more reliable than
electric-indent-mode.

[[https://github.com/Malabarba/aggressive-indent-mode][Artur Malabarba]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package aggressive-indent
    :hook ((css-mode . aggressive-indent-mode)
           (emacs-lisp-mode . aggressive-indent-mode)
           (js-mode . aggressive-indent-mode)
           (lisp-mode . aggressive-indent-mode))
    :custom (aggressive-indent-comments-too))
#+END_SRC

*** =electric-operator=

=electric-operator= is an emacs minor-mode to automatically add spacing around
operators.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package electric-operator
    :delight
    :hook (python-mode . electric-operator-mode))
#+END_SRC

*** =gnuplot=

To generate a fast and quality graphic, =gnuplot= is perfect.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package gnuplot
    :ensure-system-package gnuplot
    :defer 2)

  (use-package gnuplot-mode
    :after gnuplot
    :mode "\\.gp\\'")
#+END_SRC

*** =move-text=

Moves the current line (or if marked, the current region's, whole lines).

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package move-text
    :bind (("M-p" . move-text-up)
           ("M-n" . move-text-down))
    :config (move-text-default-bindings))
#+END_SRC

*** =paradox=

Improved GNU Emacs standard package menu.

#+BEGIN_QUOTE
Project for modernizing Emacs' Package Menu. With improved appearance, mode-line
information. Github integration, customizability, asynchronous upgrading, and
more.

[[https://github.com/Malabarba/paradox][Artur Malabarba]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package paradox
    :defer 1
    :custom
    (paradox-column-width-package 27)
    (paradox-column-width-version 13)
    (paradox-execute-asynchronously t)
    (paradox-hide-wiki-packages t)
    :config
    (paradox-enable)
    (remove-hook 'paradox-after-execute-functions #'paradox--report-buffer-print))
#+END_SRC

*** =rainbow-mode=

Colorize colors as text with their value.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-mode
    :delight
    :hook (prog-mode))
#+END_SRC

**** Replace the current file with the saved one

Avoids call the function or reload Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package autorevert
    :ensure nil
    :delight auto-revert-mode
    :bind ("C-x R" . revert-buffer)
    :custom (auto-revert-verbose nil)
    :config (global-auto-revert-mode 1))
#+END_SRC

*** =try=

Useful to temporary use a package.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package try :defer 5)
#+END_SRC

*** =undo-tree=

GNU Emacs's undo system allows you to recover any past state of a buffer. To do
this, Emacs treats "undo itself as another editing that can be undone".

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package undo-tree
    :delight
    :bind ("C--" . undo-tree-redo)
    :init (global-undo-tree-mode)
    :custom
    (undo-tree-visualizer-timestamps t)
    (undo-tree-visualizer-diff t))
#+END_SRC

*** =which-key=

It's difficult to remember all the keyboard shortcuts. The =which-key= package
helps to solve this.

I used =guide-key= in my past days, but =which-key= is a good replacement.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package which-key
    :defer 0.2
    :delight
    :config (which-key-mode))
#+END_SRC
** Icons

To integrate icons with =doom-modeline=, =switch-to-buffer=, =counsel-find-file=
and many other functions; [[https://github.com/domtronn/all-the-icons.el/][all-the-icons]] is just the best package that you can
find.

*NOTE:* if it's the first time that you install the package, you must run
=M-x all-the-icons-install-fonts=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package all-the-icons :defer 0.5)
#+END_SRC

** Ivy

I used =helm= before, but I find =ivy= faster and lighter.

#+BEGIN_QUOTE
Ivy is a generic completion mechanism for Emacs. While it operates similarly to
other completion schemes such as icomplete-mode, Ivy aims to be more efficient,
smaller, simpler, and smoother to use yet highly customizable.

[[https://github.com/abo-abo/ivy][Oleh Krehel]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package counsel
      :after ivy
      :delight
      :bind (("C-x C-d" . counsel-dired-jump)
             ("C-x C-h" . counsel-minibuffer-history)
             ("C-x C-l" . counsel-find-library)
             ("C-x C-r" . counsel-recentf)
             ("C-x C-u" . counsel-unicode-char)
             ("C-x C-v" . counsel-set-variable))
      :config (counsel-mode)
      :custom (counsel-rg-base-command "rg -S -M 150 --no-heading --line-number --color never %s"))

    (use-package ivy
      :delight
      :after ivy-rich
      :bind (("C-x b" . ivy-switch-buffer)
             ("C-x B" . ivy-switch-buffer-other-window)
             ("M-H"   . ivy-resume)
             :map ivy-minibuffer-map
             ("<tab>" . ivy-alt-done)
             ("C-i" . ivy-partial-or-done)
             ("S-SPC" . nil)
             :map ivy-switch-buffer-map
             ("C-k" . ivy-switch-buffer-kill))
      :custom
      (ivy-case-fold-search-default t)
      (ivy-count-format "(%d/%d) ")
      (ivy-re-builders-alist '((t . ivy--regex-plus)))
      (ivy-use-virtual-buffers t)
      :config (ivy-mode))

    (use-package ivy-pass
      :after ivy
      :commands ivy-pass)

    (use-package ivy-rich
      :defer 0.1
      :preface
      (defun ivy-rich-branch-candidate (candidate)
        "Displays the branch candidate of the candidate for ivy-rich."
        (let ((candidate (expand-file-name candidate ivy--directory)))
          (if (or (not (file-exists-p candidate)) (file-remote-p candidate))
              ""
            (format "%s%s"
                    (propertize
                     (replace-regexp-in-string abbreviated-home-dir "~/"
                                               (file-name-directory
                                                (directory-file-name candidate)))
                     'face 'font-lock-doc-face)
                    (propertize
                     (file-name-nondirectory
                      (directory-file-name candidate))
                     'face 'success)))))

      (defun ivy-rich-compiling (candidate)
        "Displays compiling buffers of the candidate for ivy-rich."
        (let* ((candidate (expand-file-name candidate ivy--directory)))
          (if (or (not (file-exists-p candidate)) (file-remote-p candidate)
                  (not (magit-git-repo-p candidate)))
              ""
            (if (my/projectile-compilation-buffers candidate)
                "compiling"
              ""))))

      (defun ivy-rich-file-group (candidate)
        "Displays the file group of the candidate for ivy-rich"
        (let ((candidate (expand-file-name candidate ivy--directory)))
          (if (or (not (file-exists-p candidate)) (file-remote-p candidate))
              ""
            (let* ((group-id (file-attribute-group-id (file-attributes candidate)))
                   (group-function (if (fboundp #'group-name) #'group-name #'identity))
                   (group-name (funcall group-function group-id)))
              (format "%s" group-name)))))

      (defun ivy-rich-file-modes (candidate)
        "Displays the file mode of the candidate for ivy-rich."
        (let ((candidate (expand-file-name candidate ivy--directory)))
          (if (or (not (file-exists-p candidate)) (file-remote-p candidate))
              ""
            (format "%s" (file-attribute-modes (file-attributes candidate))))))

      (defun ivy-rich-file-size (candidate)
        "Displays the file size of the candidate for ivy-rich."
        (let ((candidate (expand-file-name candidate ivy--directory)))
          (if (or (not (file-exists-p candidate)) (file-remote-p candidate))
              ""
            (let ((size (file-attribute-size (file-attributes candidate))))
              (cond
               ((> size 1000000) (format "%.1fM " (/ size 1000000.0)))
               ((> size 1000) (format "%.1fk " (/ size 1000.0)))
               (t (format "%d " size)))))))

      (defun ivy-rich-file-user (candidate)
        "Displays the file user of the candidate for ivy-rich."
        (let ((candidate (expand-file-name candidate ivy--directory)))
          (if (or (not (file-exists-p candidate)) (file-remote-p candidate))
              ""
            (let* ((user-id (file-attribute-user-id (file-attributes candidate)))
                   (user-name (user-login-name user-id)))
              (format "%s" user-name)))))

      (defun ivy-rich-switch-buffer-icon (candidate)
        "Returns an icon for the candidate out of `all-the-icons'."
        (with-current-buffer
            (get-buffer candidate)
          (let ((icon (all-the-icons-icon-for-mode major-mode :height 0.9)))
            (if (symbolp icon)
                (all-the-icons-icon-for-mode 'fundamental-mode :height 0.9)
              icon))))
      :config
      (plist-put ivy-rich-display-transformers-list
                 'counsel-find-file
                 '(:columns
                   ((ivy-rich-candidate               (:width 73))
                    (ivy-rich-file-user               (:width 8 :face font-lock-doc-face))
                    (ivy-rich-file-group              (:width 4 :face font-lock-doc-face))
                    (ivy-rich-file-modes              (:width 11 :face font-lock-doc-face))
                    (ivy-rich-file-size               (:width 7 :face font-lock-doc-face))
                    (ivy-rich-file-last-modified-time (:width 30 :face font-lock-doc-face)))))
      (plist-put ivy-rich-display-transformers-list
                 'counsel-projectile-switch-project
                 '(:columns
                   ((ivy-rich-branch-candidate        (:width 80))
                    (ivy-rich-compiling))))
      (plist-put ivy-rich-display-transformers-list
                 'ivy-switch-buffer
                 '(:columns
                   ((ivy-rich-switch-buffer-icon       (:width 2))
                    (ivy-rich-candidate                (:width 40))
                    (ivy-rich-switch-buffer-size       (:width 7))
                    (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right))
                    (ivy-rich-switch-buffer-major-mode (:width 20 :face warning)))
                   :predicate (lambda (cand) (get-buffer cand))))
      (ivy-rich-mode 1))

    (use-package all-the-icons-ivy
      :after (all-the-icons ivy)
      :custom (all-the-icons-ivy-buffer-commands '(ivy-switch-buffer-other-window))
      :config
      (add-to-list 'all-the-icons-ivy-file-commands 'counsel-dired-jump)
      (add-to-list 'all-the-icons-ivy-file-commands 'counsel-find-library)
      (all-the-icons-ivy-setup))

    (use-package swiper
      :after ivy
      :bind (("C-s" . swiper)
             :map swiper-map
             ("M-%" . swiper-query-replace)))
#+END_SRC

** Linters

Flycheck lints warnings and errors directly within buffers.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flycheck
    :defer 2
    :delight
    :init (global-flycheck-mode)
    :custom
    (flycheck-display-errors-delay .3)
    (flycheck-pylintrc "~/.pylintrc")
    (flycheck-python-pylint-executable "/usr/bin/pylint")
    (flycheck-stylelintrc "~/.stylelintrc.json")
    :config
    (flycheck-add-mode 'javascript-eslint 'web-mode)
    (flycheck-add-mode 'typescript-tslint 'web-mode))
#+END_SRC

** Navigation

Navigation is an important part of productivity. The next function is a more
efficient way to go to the beginning of a line with =move-beginning-of-line=
(=C-a=) and =back-to-indentation= (=M-m=).

*FROM:* http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/smarter-move-beginning-of-line (arg)
    "Moves point back to indentation of beginning of line.

     Move point to the first non-whitespace character on this line.
     If point is already there, move to the beginning of the line.
     Effectively toggle between the first non-whitespace character and
     the beginning of the line.

     If ARG is not nil or 1, move forward ARG - 1 lines first. If
     point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  (global-set-key (kbd "C-a") 'my/smarter-move-beginning-of-line)

  (use-package imenu
    :ensure nil
    :bind ("C-r" . imenu))
#+END_SRC

** Parentheses

Managing parentheses can be painful. One of the first things you want to do is
to change the appearance of the highlight of the parentheses pairs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package faces
    :ensure nil
    :custom (show-paren-delay 0)
    :config
    (set-face-background 'show-paren-match "#262b36")
    (set-face-bold 'show-paren-match t)
    (set-face-foreground 'show-paren-match "#ffffff"))
#+END_SRC

*** =rainbow-delimiters=

#+BEGIN_QUOTE
rainbow-delimiters is a "rainbow parentheses"-like mode which highlights
delimiters such as parentheses, brackets or braces according to their
depth. Each successive level is highlighted in a different color. This makes it
easy to spot matching delimiters, orient yourself in the code, and tell which
statements are at a given depth.

[[https://github.com/Fanael/rainbow-delimiters][Fanael Linithien]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

*** =smartparens=

In my opinion, it is the most powerful package to deal with the
parenthesis. Anyway, if you don't like it, you can try taking a look at
=paredit= or =autopair=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package smartparens
    :defer 1
    :delight
    :custom (sp-escape-quotes-after-insert nil)
    :config (smartparens-global-mode 1))
#+END_SRC

** PDF

#+BEGIN_QUOTE
PDF Tools is, among other things, a replacement of DocView for PDF files. The
key difference is that pages are not pre-rendered by e.g. ghostscript and stored
in the file-system, but rather created on-demand and stored in memory.

[[https://github.com/politza/pdf-tools][Andras Politz]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package pdf-tools
    :defer 1
    :magic ("%PDF" . pdf-view-mode)
    :init (pdf-tools-install :no-query))

  (use-package pdf-view
    :ensure nil
    :after pdf-tools
    :bind (:map pdf-view-mode-map
                ("C-s" . isearch-forward)
                ("d" . pdf-annot-delete)
                ("h" . pdf-annot-add-highlight-markup-annotation)
                ("t" . pdf-annot-add-text-annotation))
    :custom
    (pdf-view-display-size 'fit-page)
    (pdf-view-resize-factor 1.1)
    (pdf-view-use-unicode-ligther nil))
#+END_SRC

** Point and Region

Increase region by semantic units. It tries to be smart about it and adapt to
the structure of the current major mode.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :bind (("C-+" . er/contract-region)
           ("C-=" . er/expand-region)))
#+END_SRC

I find useful to delete a line and a region with only =C-w=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice kill-region (before slick-cut activate compile)
    "When called interactively with no active region, kill a single line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))
#+END_SRC

** Projectile

#+BEGIN_QUOTE
Projectile is a project interaction library for Emacs. Its goal is to provide a
nice set of features operating on a project level without introducing external
dependencies (when feasible). For instance - finding project files has a
portable implementation written in pure Emacs Lisp without the use of GNU find
(but for performance sake an indexing mechanism backed by external commands
exists as well).

[[https://github.com/bbatsov/projectile][Bozhidar Batsov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile
    :defer 1
    :preface
    (defun my/projectile-compilation-buffers (&optional project)
      "Get a list of a project's compilation buffers.
    If PROJECT is not specified the command acts on the current project."
      (let* ((project-root (or project (projectile-project-root)))
             (buffer-list (mapcar #'process-buffer compilation-in-progress))
             (all-buffers (cl-remove-if-not
                           (lambda (buffer)
                             (projectile-project-buffer-p buffer project-root))
                           buffer-list)))
        (if projectile-buffers-filter-function
            (funcall projectile-buffers-filter-function all-buffers)
          all-buffers)))
    :custom
    (projectile-completion-system 'ivy)
    (projectile-enable-caching t)
    (projectile-keymap-prefix (kbd "C-c C-p"))
    (projectile-mode-line '(:eval (projectile-project-name)))
    :config (projectile-global-mode))

  (use-package counsel-projectile
    :after (counsel projectile)
    :config (counsel-projectile-mode 1))
#+END_SRC

** Recent Files

Provides fast access to the recent files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package recentf
    :bind ("C-c r" . recentf-open-files)
    :init (recentf-mode)
    :custom
    (recentf-exclude (list "COMMIT_EDITMSG"
                           "~$"
                           "/scp:"
                           "/ssh:"
                           "/sudo:"
                           "/tmp/"))
    (recentf-max-menu-items 15)
    (recentf-max-saved-items 200)
    :config (run-at-time nil (* 5 60) 'recentf-save-list))
#+END_SRC
** Version Control

It is quite common to work on Git repositories, so it is important to have a
configuration that we like.

#+BEGIN_QUOTE
[[https://github.com/magit/magit][Magit]] is an interface to the version control system Git, implemented as an Emacs
package. Magit aspires to be a complete Git porcelain. While we cannot (yet)
claim that Magit wraps and improves upon each and every Git command, it is
complete enough to allow even experienced Git users to perform almost all of
their daily version control tasks directly from within Emacs. While many fine
Git clients exist, only Magit and Git itself deserve to be called porcelains.

[[https://github.com/tarsius][Jonas Bernoulli]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-commit
    :after magit
    :hook (git-commit-mode . my/git-commit-auto-fill-everywhere)
    :custom (git-commit-summary-max-length 50)
    :preface
    (defun my/git-commit-auto-fill-everywhere ()
      "Ensures that the commit body does not exceed 72 characters."
      (setq fill-column 72)
      (setq-local comment-auto-fill-only-comments nil)))

  (use-package magit :defer 0.3)

  (use-package smerge-mode
    :after hydra
    :hook (magit-diff-visit-file . (lambda ()
                                     (when smerge-mode
                                       (hydra-merge/body)))))
#+END_SRC

In addition to that, I like to see the lines that are being modified in the file
while it is being edited.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-gutter
    :defer 0.3
    :delight
    :init (global-git-gutter-mode +1))
#+END_SRC

Finally, one last package that I like to use with Git to easily see the changes
made by previous commits.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-timemachine
    :defer 1
    :delight)
#+END_SRC

** Whitespaces

It is often annoying to see unnecessary blank spaces at the end of a line or
file. Let's get ride of them:

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package simple
    :ensure nil
    :hook (before-save . delete-trailing-whitespace))
#+END_SRC

*** =hungry-delete=

#+BEGIN_QUOTE
Deleting a whitespace character will delete all whitespace until the next
non-whitespace character.

[[https://github.com/nflath/hungry-delete][Nathaniel Flath]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hungry-delete
    :defer 0.7
    :delight
    :config (global-hungry-delete-mode))
#+END_SRC

** Windows

Don't ask before killing a buffer. I know what I'm doing.

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key [remap kill-buffer] #'kill-this-buffer)
#+END_SRC

Most of the time, when I open a new window with =C-x 2= or =C-x 3= it is to
switch directly to it and perform an action. By default, GNU Emacs does not give
focus to the new window created. I have no idea why this is not the default
behavior. But let's refine these keys:

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package window
    :ensure nil
    :bind (("C-x 3" . hsplit-last-buffer)
           ("C-x 2" . vsplit-last-buffer))
    :preface
    (defun hsplit-last-buffer ()
      "Gives the focus to the last created horizontal window."
      (interactive)
      (split-window-horizontally)
      (other-window 1))

    (defun vsplit-last-buffer ()
      "Gives the focus to the last created vertical window."
      (interactive)
      (split-window-vertically)
      (other-window 1)))
#+END_SRC

*** =switch-window=

Displays an overlay in each window showing a unique key, then asks the user
where to move in the window.

Most people use =ace-window=, but I prefer =switch-window= because I find this
package more ergonomic by using the fact of displaying the buffer number by
hiding its contents.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package switch-window
    :bind (("C-x o" . switch-window)
           ("C-x w" . switch-window-then-swap-buffer)))
#+END_SRC

*** =windmove=

Allows you to move from one window to another with something more natural than
cycling through =C-x o= (=other-window=).

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package windmove
    :bind (("C-c h" . windmove-left)
           ("C-c j" . windmove-down)
           ("C-c k" . windmove-up)
           ("C-c l" . windmove-right)))
#+END_SRC

*** =winner=

I often undo's and redo's with window configurations.

#+BEGIN_QUOTE
Winner mode is a global minor mode that records the changes in the window
configuration (i.e. how the frames are partitioned into windows) so that the
changes can be "undone" using the command =winner-undo=. By default, this one is
bound to the key sequence ctrl-c left. If you change your mind (while undoing),
you can press ctrl-c right (calling =winner-redo=).

[[https://github.com/emacs-mirror/emacs/blob/master/lisp/winner.el][Ivar Rummelhoff]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package winner
    :defer 2
    :config (winner-mode 1))
#+END_SRC

** Word Wrap

I like to have lines of the same length.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package simple
    :ensure nil
    :delight (auto-fill-function)
    :bind ("C-x p" . pop-to-mark-command)
    :hook ((prog-mode . turn-on-auto-fill)
           (text-mode . turn-on-auto-fill))
    :custom (set-mark-command-repeat-pop t))
#+END_SRC

** YASnippet

#+BEGIN_QUOTE
YASnippet is a template system for Emacs. It allows you to type an abbreviation
and automatically expand it into function templates.

[[https://github.com/joaotavora/yasnippet][João Távora]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package yasnippet-snippets
    :after yasnippet
    :config (yasnippet-snippets-initialize))

  (use-package yasnippet
    :delight yas-minor-mode " υ"
    :hook (yas-minor-mode . my/disable-yas-if-no-snippets)
    :config (yas-global-mode)
    :preface
    (defun my/disable-yas-if-no-snippets ()
      (when (and yas-minor-mode (null (yas--get-snippet-tables)))
        (yas-minor-mode -1))))

  (use-package ivy-yasnippet :after yasnippet)
  (use-package react-snippets :after yasnippet)
#+END_SRC

* Org-Mode

One of my favorite modes in GNU Emacs. I mainly use it to organize my life, take
notes and make my presentations, but you can do lots of things with
it. =org-mode= it's like the sky, without limits.

#+BEGIN_QUOTE
Org mode is for keeping notes, maintaining TODO lists, planning projects, and
authoring documents with a fast and effective plain-text system.

[[http://orgmode.org/][Carsten Dominik]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org
    :ensure org-plus-contrib
    :delight "Θ "
    :bind ("C-c i" . org-insert-structure-template)
    :preface
    (defun my/org-compare-times (clocked estimated)
      "Gets the ratio between the timed time and the estimated time."
      (if (and (> (length clocked) 0) estimated)
          (format "%.2f"
                  (/ (* 1.0 (org-hh:mm-string-to-minutes clocked))
                     (org-hh:mm-string-to-minutes estimated)))
        ""))

    (defun my/org-archive-done-tasks ()
      "Archives finished or cancelled tasks."
      (interactive)
      (org-map-entries
       (lambda ()
         (org-archive-subtree)
         (setq org-map-continue-from (outline-previous-heading)))
       "TODO=\"DONE\"|TODO=\"CANCELLED\"" (if (org-before-first-heading-p) 'file 'tree)))

    (defun my/org-jump ()
      "Jumps to a specific task."
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'org-refile)))

    (defun my/org-use-speed-commands-for-headings-and-lists ()
      "Activates speed commands on list items too."
      (or (and (looking-at org-outline-regexp) (looking-back "^\**"))
          (save-excursion (and (looking-at (org-item-re)) (looking-back "^[ \t]*")))))
    (defmacro ignore-args (fnc)
      "Returns function that ignores its arguments and invokes FNC."
      `(lambda (&rest _rest)
         (funcall ,fnc)))
    :hook ((after-save . my/config-tangle)
           (auto-save . org-save-all-org-buffers)
           (org-mode . org-indent-mode))
    :custom
    (org-archive-location "~/.personal/archives/%s::")
    (org-blank-before-new-entry '((heading . t)
                                  (plain-list-item . t)))
    (org-cycle-include-plain-lists 'integrate)
    (org-ditaa-jar-path "~/.local/lib/ditaa0_9.jar")
    (org-expiry-inactive-timestamps t)
    (org-export-backends '(ascii beamer html icalendar latex man md org texinfo))
    (org-log-done 'time)
    (org-log-into-drawer "LOGBOOK")
    (org-modules '(org-crypt
                   org-habit
                   org-info
                   org-irc
                   org-mouse
                   org-protocol
                   org-tempo))
    (org-refile-allow-creating-parent-nodes 'confirm)
    (org-refile-use-cache nil)
    (org-refile-use-outline-path nil)
    (org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
    (org-startup-folded nil)
    (org-startup-with-inline-images t)
    (org-tag-alist '(("@coding" . ?c)
                     ("@computer" . ?l)
                     ("@errands" . ?e)
                     ("@home" . ?h)
                     ("@phone" . ?p)
                     ("@reading" . ?r)
                     ("@school" . ?s)
                     ("@work" . ?b)
                     ("@writing" . ?w)
                     ("crypt" . ?C)
                     ("fuzzy" . ?0)
                     ("highenergy" . ?1)))
    (org-tags-exclude-from-inheritance '("crypt" "project"))
    (org-todo-keywords '((sequence "TODO(t)"
                                   "STARTED(s)"
                                   "WAITING(w@/!)"
                                   "SOMEDAY(.)" "|" "DONE(x!)" "CANCELLED(c@)")
                         (sequence "TOBUY"
                                   "TOSHRINK"
                                   "TOCUT"
                                   "TOSEW" "|" "DONE(x)")))
    (org-use-effective-time t)
    (org-use-speed-commands 'my/org-use-speed-commands-for-headings-and-lists)
    (org-yank-adjusted-subtrees t)
    :config
    (add-to-list 'org-global-properties '("Effort_ALL". "0:05 0:15 0:30 1:00 2:00 3:00 4:00"))
    (add-to-list 'org-speed-commands-user '("!" my/org-clock-in-and-track))
    (add-to-list 'org-speed-commands-user '("$" call-interactively 'org-archive-subtree))
    (add-to-list 'org-speed-commands-user '("d" my/org-move-line-to-destination))
    (add-to-list 'org-speed-commands-user '("i" call-interactively 'org-clock-in))
    (add-to-list 'org-speed-commands-user '("o" call-interactively 'org-clock-out))
    (add-to-list 'org-speed-commands-user '("s" call-interactively 'org-schedule))
    (add-to-list 'org-speed-commands-user '("x" org-todo "DONE"))
    (add-to-list 'org-speed-commands-user '("y" org-todo-yesterday "DONE"))
    (advice-add 'org-deadline :after (ignore-args #'org-save-all-org-buffers))
    (advice-add 'org-schedule :after (ignore-args #'org-save-all-org-buffers))
    (advice-add 'org-store-log-note :after (ignore-args #'org-save-all-org-buffers))
    (advice-add 'org-todo :after (ignore-args #'org-save-all-org-buffers))
    (org-clock-persistence-insinuate)
    (org-load-modules-maybe t))
#+END_SRC

If like me, you're tired of manually updating your tables of contents, =toc-org=
will maintain a table of contents at the first heading that has a =:TOC:= tag.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package toc-org
    :after org
    :hook (org-mode . toc-org-enable))
#+END_SRC

For a cleaner online mode.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-indent :ensure nil :after org :delight)
#+END_SRC

** Agenda

Nowadays, it is crucial to be organized. Even more than before. That is why it
is important to take the time to make a configuration that is simple to use and
that makes your life easier with an irreproachable organization.

=org-agenda= allows me to be organized with daily tasks. As a result, I can use
my time to the fullest.

I put my =org= files in [[https://github.com/syncthing/syncthing][Syncthing]] in order to be able to check my agenda and
update it from several computers and smartphones.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-agenda
    :ensure nil
    :after org
    :bind (:map org-agenda-mode-map
                ("X" . my/org-agenda-mark-done-and-add-followup)
                ("x" . my/org-agenda-done))
    :preface
    (defun my/org-agenda-done (&optional arg)
      "Mark current TODO as done.
    This changes the line at point, all other lines in the agenda referring to
    the same tree node, and the headline of the tree node in the Org-mode file."
      (interactive "P")
      (org-agenda-todo "DONE"))

    (defun my/org-agenda-mark-done-and-add-followup ()
      "Mark the current TODO as done and add another task after it.
     Creates it at the same level as the previous task, so it's better to use
     this with to-do items than with projects or headings."
      (interactive)
      (org-agenda-todo "DONE")
      (org-agenda-switch-to)
      (org-capture 0 "t"))
    :custom
    (org-agenda-dim-blocked-tasks t)
    (org-agenda-files '("~/.personal/agenda"))
    (org-agenda-inhibit-startup t)
    (org-agenda-show-log t)
    (org-agenda-skip-deadline-if-done t)
    (org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
    (org-agenda-skip-scheduled-if-done t)
    (org-agenda-span 2)
    (org-agenda-start-on-weekday 6)
    (org-agenda-sticky nil)
    (org-agenda-tags-column -100)
    (org-agenda-time-grid '((daily today require-timed)))
    (org-agenda-use-tag-inheritance t)
    (org-columns-default-format "%14SCHEDULED %Effort{:} %1PRIORITY %TODO %50ITEM %TAGS")
    (org-default-notes-file "~/.personal/agenda/organizer.org")
    (org-directory "~/.personal")
    (org-enforce-todo-dependencies t)
    (org-habit-completed-glyph ?✓)
    (org-habit-graph-column 80)
    (org-habit-show-habits-only-for-today nil)
    (org-habit-today-glyph ?‖)
    (org-track-ordered-property-with-tag t))
#+END_SRC

** Bullets

Prettier [[https://github.com/sabof/org-bullets][bullets]] in org-mode.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("●" "►" "▸")))
#+END_SRC

** Capture

=org-capture= templates saves you a lot of time when adding new entries. I use
it to quickly record tasks, ledger entries, notes and other semi-structured
information.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-capture
    :ensure nil
    :after org
    :preface
    (defvar my/org-basic-task-template "* TODO %^{Task}
  :PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
  :END:
  Captured %<%Y-%m-%d %H:%M>" "Template for basic task.")

    (defvar my/org-contacts-template "* %(org-contacts-template-name)
  :PROPERTIES:
  :ADDRESS: %^{289 Cleveland St. Brooklyn, 11206 NY, USA}
  :BIRTHDAY: %^{yyyy-mm-dd}
  :EMAIL: %(org-contacts-template-email)
  :NOTE: %^{NOTE}
  :END:" "Template for org-contacts.")

    (defvar my/org-ledger-card-template "%(org-read-date) %^{Payee}
    Expenses:%^{Account}  €%^{Amount}
    Liabilities:CreditsCards:Belfius" "Template for credit card transaction with ledger.")

    (defvar my/org-ledger-cash-template "%(org-read-date) * %^{Payee}
    Expenses:%^{Account}  €%^{Amount}
    Assets:Cash:Wallet" "Template for cash transaction with ledger.")
    :custom
    (org-capture-templates
     `(("B" "Book" checkitem (file+headline "~/.personal/other/books.org" "Books")
        "- [ ] %^{Book}"
        :immediate-finish t)

       ("L" "Learning" checkitem (file+headline "~/.personal/other/learning.org" "Things")
        "- [ ] %^{Thing}"
        :immediate-finish t)

       ("M" "Movie" checkitem (file+headline "~/.personal/other/movies.org" "Movies")
        "- [ ] %^{Movie}"
        :immediate-finish t)

       ("P" "Purchase" checkitem (file+headline "~/.personal/other/purchases.org" "Purchases")
        "- [ ] %^{Item}"
        :immediate-finish t)

       ("c" "Contact" entry (file+headline "~/.personal/agenda/contacts.org" "Friends"),
        my/org-contacts-template
        :empty-lines 1)

       ("l" "Ledger")

       ("lb" "Bank" plain (file ,(format "~/.personal/ledger/ledger-%s.dat" (format-time-string "%Y"))),
        my/org-ledger-card-template
        :empty-lines 1
        :immediate-finish t)

       ("lc" "Cash" plain (file ,(format "~/.personal/ledger/ledger-%s.dat" (format-time-string "%Y"))),
        my/org-ledger-cash-template
        :empty-lines 1
        :immediate-finish t)

       ("f" "FindMyCat" entry (file+headline "~/.personal/agenda/findmycat.org" "Tasks"),
        my/org-basic-task-template
        :empty-lines 1)

       ("p" "People" entry (file+headline "~/.personal/agenda/people.org" "Tasks"),
        my/org-basic-task-template
        :empty-lines 1)

       ("s" "School" entry (file+headline "~/.personal/agenda/school.org" "Tasks"),
        my/org-basic-task-template
        :empty-lines 1)

       ("t" "Task" entry (file+headline "~/.personal/agenda/organizer.org" "Tasks"),
        my/org-basic-task-template
        :empty-lines 1))))
#+END_SRC

** Contacts

The best solution to maintain your contacts. I tend to use =org-contacts= to
remember their birthdays, so I can be the first to wish them that. Be careful
that to install it, this one is available with =org-plus-contrib=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-contacts
    :ensure nil
    :after org
    :custom (org-contacts-files '("~/.personal/agenda/contacts.org")))
#+END_SRC

** Customization

Let's change the foreground and the weight of each keyword.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-faces
    :ensure nil
    :after org
    :custom
    (org-todo-keyword-faces
     '(("DONE" . (:foreground "cyan" :weight bold))
       ("SOMEDAY" . (:foreground "gray" :weight bold))
       ("TODO" . (:foreground "green" :weight bold))
       ("WAITING" . (:foreground "red" :weight bold)))))
#+END_SRC
** Journal

Recently, I started writing a journal about my daily life as I read that
journals improve mental claritym, help solve problems, improve overall focus,
insight and understanding, track the overall development and facilitate personal
growth.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-journal
    :after org
    :bind (("C-c T" . org-journal-new-entry)
           ("C-c Y" . journal-file-yesterday))
    :preface
    (defun get-journal-file-yesterday ()
      "Gets filename for yesterday's journal entry."
      (let* ((yesterday (time-subtract (current-time) (days-to-time 1)))
             (daily-name (format-time-string "%Y%m%d" yesterday)))
        (expand-file-name (concat org-journal-dir daily-name))))

    (defun journal-file-yesterday ()
      "Creates and load a file based on yesterday's date."
      (interactive)
      (find-file (get-journal-file-yesterday)))
    :custom
    (org-journal-date-format "%e %b %Y (%A)")
    (org-journal-dir (format "~/.personal/journal/" (format-time-string "%Y")))
    (org-journal-enable-encryption t)
    (org-journal-file-format "%Y%m%d")
    (org-journal-time-format ""))
#+END_SRC

** Languages

With that, I can compile many languages with =org-mode=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ob-C :ensure nil :after org)
  (use-package ob-css :ensure nil :after org)
  (use-package ob-ditaa :ensure nil :after org)
  (use-package ob-dot :ensure nil :after org)
  (use-package ob-emacs-lisp :ensure nil :after org)
  (use-package ob-gnuplot :ensure nil :after org)
  (use-package ob-java :ensure nil :after org)
  (use-package ob-js :ensure nil :after org)

  (use-package ob-latex
    :ensure nil
    :after org
    :custom (org-latex-compiler "xelatex"))

  (use-package ob-ledger :ensure nil :after org)
  (use-package ob-makefile :ensure nil :after org)
(use-package ob-org :ensure nil :after org)

  (use-package ob-python :ensure nil :after org)
  (use-package ob-ruby :ensure nil :after org)
  (use-package ob-shell :ensure nil :after org)
  (use-package ob-sql :ensure nil :after org)
#+END_SRC
